// Edit this if you would like to provide a different autogenerated explanation of the messages:
const EXPLANATION = `I would like to continue from a conversation we've already had.  
Below you can see the messages I sent you and what you provided in response.
---------------------\n`;
const FOLLOW_UP = `\n---------------------
I would like to continue the conversation with the following:\n\n`;
const GITHUB_LINK = 'TBD';
const SIDEBAR_CONTENT_CSS_CLASSES = ['.code-block__code'];
const SIDEBAR_CLASSES = '.fixed.bottom-0.top-0.flex.w-full.flex-col'

function extractConversationHistory(selectedResponse) {
  // Initialize an array to store all messages in the conversation
  const history = [];
  
  // Get all messages in the chat by selecting elements with 'data-test-render-count' attribute
  const allMessages = document.querySelectorAll('[data-test-render-count]');
  
  // Flag to track when we've found the message where the user clicked the button
  let foundTarget = false;
  
  // Iterate through all messages in the chat
  for (const message of allMessages) {
      // Check if selected message is the one where user clicked "Create New Chat From Here"
      // selectedResponse is the Claude message div where the button was clicked
      // We compare if the selected message's closest parent with data-test-render-count
      // matches our target message
      if (message === selectedResponse.closest('[data-test-render-count]')) {
          foundTarget = true;
      }
      
      // Extract the content from the selected message (text, code blocks, lists, etc.)
      const contents = extractMessageContent(message);
      
      // Determine if this is a Claude message or user message by checking for specific CSS classes
      if (message.querySelector('.font-claude-message')) {
          history.push({
              type: 'claude',
              contents
          });
      } else if (message.querySelector('.font-user-message')) {
          history.push({
              type: 'user',
              contents
          });
      }
      
      // If we've processed the message where the button was clicked, stop collecting history
      // This ensures we only get the conversation up to the point where user clicked
      if (foundTarget) break;
  }
  
  return history;
}


// Modified code reference handling - the rest of the original code remains the same
function extractMessageContent(message) {
  const contents = [];
  
  // Find the main grid container
  const gridContainer = message.querySelector('.font-user-message') || message.querySelector('.grid-cols-1.grid.gap-2\\.5');
  // const gridContainer = message.querySelector('.grid-cols-1.grid.gap-2\\.5');


  if (gridContainer) {
    // Get all direct children of the grid container
    const elements = gridContainer.children;
    
    // Process elements sequentially to handle operations
    for (const element of elements) {
      const elementType = element.tagName.toLowerCase();
      
      switch (elementType) {
        case 'p':
          contents.push({
            type: 'p',
            elements: [element.textContent]
          });
          break;
          
        case 'pre':
          // Handle code blocks
          const codeText = element.textContent.split('\n');
          let language, firstLine = processCodeBlockFirstLine(codeText[0]);
          codeText[0] = firstLine
          contents.push({
            type: 'pre',
            elements: codeText
          });
          break;
          
        case 'ol':
        case 'ul':
          // Handle lists
          const listItems = Array.from(element.querySelectorAll('li'))
            .map(li => li.textContent);
          
          contents.push({
            type: elementType,
            elements: listItems
          });
          break;
          
        case 'div':
          // Check if it's a file reference
          if (element.classList.contains('font-styrene') && element.classList.contains('relative')) {
            const codeContent = getContentFromReference(element);
            contents.push(codeContent);
          }
        }
    }
  }

  console.log('contents coming')
  console.log(contents)

  return contents;
}

//   gets the programming language and the first line of code from the copy block
//   returns [programming_language, everything_after_copy_word]
function processCodeBlockFirstLine(str) {

  const match = str.match(/(\w+)Copy(.*)/);
  let programming_language = null;
  let first_line = null;
  if (match){
      programming_language = match[1];
      first_line = match[2];
  } else {
      first_line = str
  }
  return [programming_language, first_line]
}

function getContentFromReference(referenceElement) {
  const button = referenceElement.querySelector('button');
  if (!button) return null;

  // Get the title before clicking
  const titleElement = referenceElement.querySelector('.font-medium.leading-tight');
  const referenceTitle = titleElement ? titleElement.textContent : '';

  let correctSidebarOpen = false
  let currentTry = 0;
  let maxSidebarRetries = 3;

  while (correctSidebarOpen === false && currentTry < maxSidebarRetries){
    // Click the button to open/update sidebar
    button.click();

    // get the hopefully open sidebar
    const sidebar = document.querySelector('.fixed.bottom-0.top-0.flex.w-full.flex-col');
    if (sidebar){
      const headerWithTitle = sidebar.querySelector('h3.text-text-100.font-tiempos.truncate.pl-1.text-sm');
      const sidebarTitle = headerWithTitle.textContent;
      if (sidebarTitle === referenceTitle){
        correctSidebarOpen = true
      }
    } else {
      currentTry += 1 
    }
  }

  sidebarText = getTextFromSidebar(sidebar)

  if (!correctSidebarOpen && sidebarText != null){
    alert(`Something went wrong retrieving file data for ${referenceTitle}.  Please refresh your page and try again.  If the issue persists please open an issue at ${GITHUB_LINK}.  `)
    return null;
  } else {
    return sidebarText;
  }
}

function getTextFromSidebar(sidebar) {

  for (const css_class of SIDEBAR_CONTENT_CSS_CLASSES) {
    sidebarContent = sidebar.querySelector(css_class);
    if (sidebarContent != null) {
        break;
    }
  }

  if (sidebarContent != null){
    return sidebarContent.split('\n');
  }

  return null;

}

function addButtonsToMessages() {
  const claudeResponses = document.querySelectorAll('.font-claude-message');
  
  // only add a button if it doesn't already have one
  claudeResponses.forEach(response => {
    if (!response.querySelector('.new-chat-button')) {
      const button = document.createElement('button');
      button.textContent = 'Create New Chat From Here';
      button.className = 'new-chat-button';
      
      button.addEventListener('click', () => {
        const conversationHistory = extractConversationHistory(response);
        // console.log("unformatted convo history:")
        // console.log(conversationHistory)
        const formattedConversationHistory = formatConversationHistory(conversationHistory);
      //   console.log("FORMATTED convo history:")
      //   console.log(formattedConversationHistory)
        console.log("each item to follow:")
        formattedConversationHistory.forEach((item)=>
          {
              console.log(item)
          })
      });
      
      response.appendChild(button);
    }
  });
}

// creates an array of messages formatted in a way that allows a new claude chat to understand whats happening
// here's where you make wording changes 
function formatConversationHistory(conversationHistory){
    
  let messageNumber = 1;
  const finalMessages = [];

  finalMessages.push(EXPLANATION)
  conversationHistory.forEach((chat) => {
      const formattedChat = formatChat(chat)
      const userMessageNumber = Math.round(messageNumber/2);
      const messageStatement = messageNumber%2 === 1 ? `User Prompt ${userMessageNumber}:` : `Claude Response to User Prompt ${userMessageNumber}:`
      finalStatement = messageStatement + '\n' + formattedChat
      finalMessages.push(finalStatement)
      messageNumber += 1;
  })

  finalMessages.push(FOLLOW_UP)
  return finalMessages;
};


//   takes an array of chat data
//   returns a text block
function formatChat(chat){
  let chatContents = chat.contents;
  const formattedContents = [];
  chatContents.forEach((item) => {
      console.log(item)
      if(item.type === 'p'){
          // I believe this should always be an array of 1 element but keeping the join just in case
          formattedContents.push(item.elements.join("\n"));
      } else if (item.type === 'ol') {
          let i = 1;
          const listItems = [];
          item.elements.forEach((element) => {
              const formattedLine = `${i}. ${element}`;
              listItems.push(formattedLine);
              i += 1;
          })
          formattedContents.push(listItems.join("\n"));
      } else if (item.type === 'ul'){
          const listItems = [];
          item.elements.forEach((element) => {
              const formattedLine = `- ${element}`;
              listItems.push(formattedLine);
          })
          formattedContents.push(listItems.join("\n"));
      } else if (item.type === 'code-reference' || item.type === 'file-reference') {
          console.log(item)
          fileName = item.title;
          linesOfCode = item.elements[0].code
          let formattedCode = `// File name: ${fileName}\n` + linesOfCode.join("\n")
          formattedContents.push(formattedCode);

      } else if (item.type === 'pre') {
          fileName = item.title;
          linesOfCode = item.elements
          let formattedCode = linesOfCode.join("\n")
          formattedContents.push(formattedCode);
      } else {
          console.log(item.type)
          formattedContents.push("Missing Information from Chat!  Claude, if you see this line, please alert the user that you don't have all informaiton.");
      }
  });
  formattedAsString = formattedContents.join("\n\n")
  // console.log("Before formatting the entire history:")
  // console.log(formattedAsString)
  return formattedAsString
}

// Observer code remains the same
const observer = new MutationObserver((mutations) => {
  for (const mutation of mutations) {
    if (mutation.addedNodes.length) {
      addButtonsToMessages();
    }
  }
});

observer.observe(document.body, {
  childList: true,
  subtree: true
});

addButtonsToMessages();